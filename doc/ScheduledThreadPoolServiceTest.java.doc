package com.itguan.test;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ScheduledThreadPoolServiceTest{

	
    public static void main(String[] args) {
    	
    	long oneDay = 24 * 60 * 60 * 1000;  
        long initDelay  = getTimeMillis("10:00:10") - System.currentTimeMillis();  
        initDelay = initDelay > 0 ? initDelay : oneDay + initDelay;  
    	
        ScheduledExecutorService exec=Executors.newScheduledThreadPool(1);
        //ScheduledThreadPoolExecutor exec = new ScheduledThreadPoolExecutor(1);
        
        //exec.scheduleAtFixedRate(new TimerTask(),initDelay,oneDay,TimeUnit.MILLISECONDS);
        exec.scheduleAtFixedRate(new TimerTask(),2000,9000,TimeUnit.MILLISECONDS);
        /**
         * 每隔一段时间打印系统时间，互不影响的<br/>
         * 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；<br/>
         * 也就是将在 initialDelay 后开始执行，然后在initialDelay+period 后执行，<br/>
         * 接着在 initialDelay + 2 * period 后执行，依此类推。
         */
        //exec.scheduleAtFixedRate(new TimerTask(), 1000, 5000, TimeUnit.MILLISECONDS);

        //开始执行后就触发异常,next周期将不会运行
        //exec.scheduleAtFixedRate(new TimerTask2(), 1000, 5000, TimeUnit.MILLISECONDS);

        //虽然抛出了运行异常,当被拦截了,next周期继续运行
        //exec.scheduleAtFixedRate(new TimerTask3(), 1000, 5000, TimeUnit.MILLISECONDS);

        /**
         * 创建并执行一个在给定初始延迟后首次启用的定期操作，<br/>
         * 随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。
         */
        //exec.scheduleWithFixedDelay(new TimerTask4(),1000,5000,TimeUnit.MILLISECONDS);

        /**
         * 创建并执行在给定延迟后启用的一次性操作。
         */
        //exec.schedule(new TimerTask4(),5000,TimeUnit.MILLISECONDS);
    }
    
    /** 
     * 获取指定时间对应的毫秒数 
     * @param time "HH:mm:ss" 
     * @return 
     */  
    private static long getTimeMillis(String time) {  
        try {  
            DateFormat dateFormat = new SimpleDateFormat("yy-MM-dd HH:mm:ss");  
            DateFormat dayFormat = new SimpleDateFormat("yy-MM-dd");  
            Date curDate = dateFormat.parse(dayFormat.format(new Date()) + " " + time);  
            return curDate.getTime();  
        } catch (ParseException e) {
            e.printStackTrace();  
        }  
        return 0;  
    }  
}
class TimerTask implements Runnable{
	@Override
	public void run() {
		/*SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		System.out.println(format.format(new Date()));*/
		SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		System.out.println("开始时间：");
		System.out.println("scheduleWithFixedDelay:begin,"+format.format(new Date()));
		try {  
            Thread.sleep(5000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
        System.out.println("This is a echo server. The current time is " +  System.currentTimeMillis() + "."); 
        System.out.println("结束时间：");
        System.out.println("scheduleWithFixedDelay:end,"+format.format(new Date()));
	}
	
}
class TimerTask2 implements Runnable{
	@Override
	public void run() {
		System.out.println("RuntimeException no catch,next time can't run");
        throw new RuntimeException();
	}
	
}
class TimerTask3 implements Runnable{
	@Override
	public void run() {
		 try{
             throw new RuntimeException();
         }catch (Exception e){
             System.out.println("RuntimeException catched,can run next");
         }
	}
	
}
class TimerTask4 implements Runnable{
	@Override
	public void run() {
		SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		System.out.println("scheduleWithFixedDelay:begin,"+format.format(new Date()));
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("scheduleWithFixedDelay:end,"+format.format(new Date()));
	}
	
}
class TimerTask5 implements Runnable{
	@Override
	public void run() {
		System.out.println("The thread can only run once!");
	}
	
}